# 超哥题解
class Solution:
    # 懵逼的时候：
        # 可否暴力解？
        # 最基本情况是哪些？
            # 如何泛化？泛化思路就是找重复的问题 -> 找 最近 重复子问题
                # 为什么强调重复性？因为CPU只能做if else, loop, 和recursion。所有问题的思路都是找重复性。
    
    # 基本情况：
        # n=1 : 1
        # n=2 : 2
        # n=3 : f(1) + f(2)
        # n=4 : f(2) + f(3)
        # 泛化：f(n) = f(n-1) + f(n-2)
        # 每层阶梯只能要么在n-1的阶梯踏一步到达，要么在n-2的阶梯踏两步到达
        # 问题：为什么f(n-1)与f(n-2)不会重复？为什么两者相加就等于f(n)?
				# 想通了：到n-1阶梯的方法有f(n-1)种，n-1到n只能迈一步也就是说只有一种方法，而n-2到n也只能一次性迈两步（迈两次一步就与f(n-1）重叠了)，由于f(n-1)与f(n-2)最后到达n的方法不同，所以不会重叠。
    
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n
        f1, f2, f3 = 1, 2, 3
        for i in range(3, n+1):
            f3 = f1 + f2
            f1 = f2
            f2 = f3            
        return f3